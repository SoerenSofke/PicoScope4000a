classdef PicoScope4000a < coder.ExternalDependency %#codegen
    properties (Constant = true)
        CHANNEL = struct(...
            'A', 0, ...
            'B', 1, ...
            'C', 2, ...
            'D', 3, ...
            'E', 4, ...
            'F', 5, ...
            'G', 6, ...
            'H', 7 ...
            );
        
        PROBE_RANGE = struct(...
            'DIFFERENTIAL_10MV', 0, ...
            'DIFFERENTIAL_20MV', 1, ...
            'DIFFERENTIAL_50MV', 2, ...
            'DIFFERENTIAL_100MV', 3, ...
            'DIFFERENTIAL_200MV', 4, ...
            'DIFFERENTIAL_500MV', 5, ...
            'DIFFERENTIAL_1V', 6, ...
            'DIFFERENTIAL_2V', 7, ...
            'DIFFERENTIAL_5V',  8, ...
            'DIFFERENTIAL_10V', 9 ...
            );
        
        COUPLING = struct( ...
            'AC', 0, ...
            'DC', 1 ...
            )
        
        SAMPLE_RATE = struct(...
            'FS_80MHZ', 0, ...
            'FS_40MHZ', 1, ...
            'FS_26p67MHZ', 2, ...
            'FS_20MHZ', 3, ...
            'FS_16MHZ', 4, ...
            'FS_13p33MHZ', 5, ...
            'FS_11p43MHZ', 6, ...
            'FS_10MHZ', 7 ...
            )
        
        RATIO_MODE = struct(...
            'NONE', 0, ...
            'AGGREGATE', 1, ...
            'DECIMATE', 2, ...
            'AVERAGE', 4 ...
            )
    end
    
    
    
    methods (Static)
        %% Basic functions defined in _ps4000aApi.h_
        function [status, handle] = openUnit()
            handle = int16(1);
            serial = int8([]);
            [status, handle] = calllib('ps4000a', 'ps4000aOpenUnit', handle, serial);
        end
        
        function [status] = setChannel(handle, CHANNEL, enabled, COUPLING, PROBE_RANGE, analogOffset)
            status = calllib('ps4000a', 'ps4000aSetChannel', handle, CHANNEL, enabled, COUPLING, PROBE_RANGE, analogOffset);
        end
        
        function [status, bufferPtr] = setDataBuffer(handle, CHANNEL, bufferLth, segmentIndex, RATIO_MODE)
            bufferPtr = libpointer('int16Ptr', zeros(bufferLth, 1));
            status = calllib('ps4000a', 'ps4000aSetDataBuffer', handle, CHANNEL, bufferPtr, bufferLth, segmentIndex, RATIO_MODE);
        end
        
        function [status, noOfSamples, overflow] = getValues(handle, startIndex, noOfSamples, downSampleRatio, RATIO_MODE, segmentIndex)
            noOfSamplesPrt = libpointer('uint32Ptr', noOfSamples);
            overflowPtr = libpointer('int16Ptr', 0);

            status = calllib('ps4000a', 'ps4000aGetValues', handle, startIndex, noOfSamplesPrt, downSampleRatio, RATIO_MODE, segmentIndex, overflowPtr);
            
            noOfSamples = get(noOfSamplesPrt, 'value');
            overflow = get(overflowPtr, 'value');
        end
        
        function [status] = closeUnit(handle)
            status = calllib('ps4000a', 'ps4000aCloseUnit', handle);
        end
        
        %% Advanced function defined in _ps4000aWrap.h_
        function [status] = runBlock(handle, preTriggerSamples, postTriggerSamples, sampleRateEn, segmentIndex)
            status = calllib('ps4000aWrap', 'RunBlock', handle, preTriggerSamples, postTriggerSamples, sampleRateEn, segmentIndex);
        end
        
        function [isReady] = isReady(handle)
            isReady = calllib('ps4000aWrap', 'IsReady', handle);
        end
        
        %% Helper functions
        function loadLibrary()
            if not(libisloaded('ps4000a'))
                loadlibrary('ps4000a.dll', @ps4000a);
            end
            
            if not(libisloaded('ps4000aWrap'))
                loadlibrary('ps4000aWrap.dll', @ps4000aWrap);
            end
        end
        
        function unloadLibrary()
            if libisloaded('ps4000a')
                unloadlibrary('ps4000a');
            end
            
            if libisloaded('ps4000aWrap')
                unloadlibrary('ps4000aWrap');
            end
        end
        
        function waitUntilDataIsReady(handle)
            while ~PicoScope4000a.isReady(handle)
            end
        end
    end
end

